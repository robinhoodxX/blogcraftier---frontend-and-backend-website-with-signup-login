npm install jsonwebtoken
npm install dotenv // for storing secret keys


Then, create a .env file in your main directory:

JWT_SECRET=your_super_secret_key_here
JWT_EXPIRES_IN=1d


Create utils/jwt.js (or similar) for signing and verifying tokens:

const jwt = require("jsonwebtoken");
require("dotenv").config();

// Sign JWT
function signToken(payload) {
  return jwt.sign(payload, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN || "1d",
  });
}

// Verify JWT middleware for protected routes
function verifyToken(req, res, next) {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Authorization header missing or invalid" });
  }

  const token = authHeader.split(" ")[1];

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded; // ⭐ attach user info to request
    next();
  } catch (err) {
    return res.status(401).json({ error: "Invalid or expired token" });
  }
}

module.exports = { signToken, verifyToken };


In your auth.js, after successfully validating the password:

const { signToken } = require("../utils/jwt"); // *

// Inside login route after bcrypt.compare
const token = signToken({ id: user.id, username: user.username, email: user.email });

// Return the token to frontend
res.status(200).json({
  message: "Login successful!",
  token,  // ⭐ JWT token
  user: {
    id: user.id,
    username: user.username,
    email: user.email,
  },
});



Example: Protect profile update or get routes (users.js):

const { verifyToken } = require("../utils/jwt"); // *

// Protect this route
router.get("/:id", verifyToken, (req, res) => {
  const { id } = req.params;

  // Optional: make sure the token user matches requested id
  if (req.user.id != id) {
    return res.status(403).json({ error: "Forbidden: You can only access your own profile" });
  }

  const sql = "SELECT id, username, email, mobile, address, gender, profile_pic FROM users WHERE id = ?";
  db.query(sql, [id], (err, results) => {
    if (err) return res.status(500).json({ error: err.message });
    res.json(results[0]);
  });
});


save the JWT in localStorage or sessionStorage after login:

localStorage.setItem("token", res.data.token);


Attach token to all protected requests:

const token = localStorage.getItem("token");

const res = await fetch(`http://localhost:5000/api/users/${userId}`, {
  headers: {
    Authorization: `Bearer ${token}`, // ⭐ attach JWT
  },
});


Optional – Auto Logout on Token Expiry

You can decode JWT on the frontend with jwt-decode to check expiry:

npm install jwt-decode

import jwtDecode from "jwt-decode";

const token = localStorage.getItem("token");
if (token) {
  const decoded = jwtDecode(token);
  if (decoded.exp * 1000 < Date.now()) {
    // Token expired
    localStorage.removeItem("token");
    navigate("/lgscrn");
  }
}

for front end -----------------------------------------------------------------


Every request to your protected backend routes (profile GET, PUT, DELETE, password PUT) must include the token in the Authorization header.

Update your fetchProfile:

useEffect(() => {
    const fetchProfile = async () => {
        const token = localStorage.getItem("token"); // ⭐ get JWT

        const res = await fetch(`http://localhost:5000/api/users/${userId}`, {
            headers: { Authorization: `Bearer ${token}` }, // ⭐ attach JWT
        });
        const data = await res.json();

        setProfile({
            username: data.username || "",
            email: data.email || "",
            password: "", // never load hashed password
            mobile: data.mobile || "",
            address: data.address || "",
            gender: data.gender || "",
            profile_pic: data.profile_pic,
        });

        setPreviewPic(
            data.profile_pic ? `http://localhost:5000${data.profile_pic}` : null
        );
    };
    fetchProfile();
}, [userId]);

Step : Include JWT in updates

When saving profile changes:

const res2 = await fetch(`http://localhost:5000/api/users/${userId}`, {
    method: "PUT",
    body: formData,
    headers: {
        Authorization: `Bearer ${localStorage.getItem("token")}`, // ⭐ attach JWT
    },
});


And for password update:

const res = await fetch(`http://localhost:5000/api/users/${userId}/password`, {
    method: "PUT",
    headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${localStorage.getItem("token")}`, // ⭐ attach JWT
    },
    body: JSON.stringify({
        oldPassword: profile.oldPassword,
        newPassword: profile.newPassword,
    }),
});

Step : Add JWT to delete

Similarly, for delete:

const res = await fetch(`http://localhost:5000/api/users/${userId}`, {
    method: "DELETE",
    headers: { Authorization: `Bearer ${localStorage.getItem("token")}` }, // ⭐ attach JWT
});

Step 5: Optional: handle 401

If a token is invalid or expired, your backend should respond 401. In that case, log out the user automatically:

if (res.status === 401) {
    alert("Session expired, please log in again.");
    handleLogout();
}
